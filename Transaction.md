# 事务

[《Java事务设计策略》](https://ress.infoq.com/minibooks/JTDS/zh/pdf/java-transactions-book-cn.pdf?Expires=1523267885&Signature=Y35UBKCPceFADVdvpjMoU8LVJhpuZh7LxasG9v4Y14cTSQtT6BmV2AkS95h00-Os~IbKlkgg7SVMRsMulJEtna0~AQHzCLCnBdnvipYKx1drobhgGf9E24iGI4egr0T22tPmFqvG7j4Bi8eXb5glhZEWgvlXsSMZF-iIwSJONHQ_&Key-Pair-Id=APKAIMZVI7QH4C5YKH6Q)

## 分布式事务

### 什么是XA事务

分布式事务处理是指一个事务涉及多个数据库操作，分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务必须产生一致的结果（全部提交或全部回滚）。

XA是X/Open DTP组织（X/Open DTP group)定义的两阶段提交协议，XA被许多数据库（如Oracle、DB2、SQL Server、MySQL）和中间件等工具（如CICS何Tuxedo）支持。

X/Open DTP模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）、通信资源管理器（CRM)四部分。在这个模型中，通常事务管理器（TM）是交易中间件，资源管理器（RM）是数据库，通信资源管理器（CRM）是消息中间件。一般情况下，某一数据库无法知道其他数据库在做什么，因此，在一个DTP环境中，交易中间件是必须的，有它通知和协调相关数据库的提交和回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。

XA就是X/Open DTP定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚）。XA接口函数由数据库厂商提供。通常情况下，交易中间件与数据库通过XA接口规范，使用两阶段提交来完成一个全局事务，XA规范的基础就是两阶段提交协议。

在第一阶段：
交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确定是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。

第二阶段：
交易中间件审查所有数据库返回的预提交结果，如所有的数据库都可以提交，交易中间件将要求所有的数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚操作，这样该全局事务被回滚。

### XA接口详解

XA接口是双向的系统接口，分布式事务是由一个应用程序（Application Program）、一个事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。事务管理器控制着JTA事务，管理事务生命周期，并协调资源。

在JTA中，事务管理器抽象为javax.transaction.TransactionManager接口，并通过底层事务服务（即JTS）实现。资源管理器负责控制和管理实际资源（如数据库或JMS队列）。

![XA](https://raw.githubusercontent.com/SoulZhong/draw/master/XA.png)

XA分布式事务是由一个或者多个Resource Manager,一个事务管理器Transaction Manager以及一个应用程序Application Program组成。

* 资源管理器：提供访问事务资源的方法，通常一个数据库就是一个资源管理器。
* 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务中的资源管理器进行通信。
* 应用程序：定义事务的边界，制定全局事务中的操作。

### XA的使用场景

许多事务管理器采用单阶段提交的模式，可以避免单一事务资源下的过度开销，以及性能下降。如果在不合适的场景中引入XA数据库驱动，特别是资源比较局限的情况下使用本地事务模型（Local Transaction Model）。

一般来说，当上下逻辑结构涉及的表或者需要协调的资源（如数据库，以及消息主题或队列等）比较多的时候，建议使用XA。或者对于该系统在未来对整个结构模块趋于稳定，要求负载、代码扩展等方面稳定性大于性能，则可能选择XA。如果这些资源并不在同一个事务中使用，就没有必要去用XA。而对于性能要求很高的系统，建议使用一阶段提交（Best Efforts 1PC）或者事务补偿机制。

### 两阶段提交的缺点

1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不处于阻塞状态。

2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）。

3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受了commit请求。而在这部分参与者街道commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。

4. 二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了，那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

### 分布式事务原理：分段式提交

分布式事务通常采用2PC协议，全称Two Phase Commitment Protocol。该协议主要为了解决在分布式数据库场景下，所有节点数据一致性的问题。分布式事务通过采用2PC协议将提交分成两个阶段：

* prepare
* commit/rollback

阶段一为准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。
阶段二为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。

### Mysql的分布式事务XA（夸数据库事务）[原文](https://blog.csdn.net/soonfly/article/details/70677138v)

[Mysql XA 文档](https://dev.mysql.com/doc/refman/5.7/en/xa.html)

两个概念:

* 资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理器还应该具有管理事务提交或回滚的能力。
* 事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。

Mysql在执行分布式事务（外部XA）的时候，Mysql服务器相当于XA事务资源管理器，与Mysql连接的客户端相当于事务管理器。

#### 事务协调者 transaction manager

因为XA事务是基于两阶段协议提交的，所以需要有一个事务协调者（transaction manager）来保证所有的事务参与者都完成了准备工作（第一阶段）。如果事务协调者（transaction manager）收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。Mysql在这个XA事务中扮演的是参与者的角色，不是事务协调者（transaction manager）。

#### Mysql的XA事务分为外部XA和内部XA

* 外部XA

用于跨多Mysql实例的分布式事务，需要应用层作为协调者。应用层负责决定提交还是回滚，崩溃时悬挂事务。Mysql数据库外部XA可以用在分布式数据库代理层，实现对Mysql数据库的分布式事务支持，例如开源的代理工具：网易的DDB，淘宝的TDDL等。

* 内部XA

用于同一实例下跨多引擎事务，由Binlog作为协调者，比如在一个存储引擎提交时，需要将提交信息写入二进制日志，这是一个分布式内部XA事务，只不过这个二进制日志的参与者是Mysql本身。Binlog作为内部的XA协调者，在Binlog中出现的内部xid，在crash recover时，由binlog负责提交。（这是因为，binlog不进行prepare，只进行commit，因此在binlog中出现的内部xid，一定能够保证其在底层各存储引擎中已经完成了prepare）。

#### XA的性能问题

XA的性能很低。一个数据库的事务和多个数据库间的XA事务性能差10倍左右。因此尽量避免XA事务，例如可以将数据写入本地，用高性能的消息系统分发数据。或者使用数据库复制等技术。只有在这些都无法实现，且性能不是瓶颈时才应该使用XA。